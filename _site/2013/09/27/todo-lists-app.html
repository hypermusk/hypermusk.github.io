<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>Todo Lists App | HyperMusk </title>
  <meta name="author" content="Felix Sun" />
  <link href="http://feeds.feedburner.com/sunfmin" rel="alternate" title="Felix Sun" type="application/atom+xml" />
  <link type="text/css" rel="stylesheet" href="/files/style.css">
</head>
<body>

<div class="site">
  <div class="title">
    <a href="/">home</a>
  </div>

  <div class="main_content">
  <h1>Todo Lists App</h1>
  <em>27 Sep 2013</em>
  <p>Here I'll describe the basic requirements of this app.</p>

<ul>
<li>You can create a Todo List</li>
<li>You can create a Todo item inside one of the lists</li>
<li>Be able to check the Todo item to mark it finish</li>
<li>Be able to mark the finished item to send it back</li>
</ul>


<p>From these requirements, I created the Go language api definition with in these directory structure:</p>

<p> <img src="/images/todo-lists-app/api.png" alt="" /></p>

<p>the <code>api.go</code> file will look like this:</p>

<pre><code>package todoapi

type TodoList struct {
    Id   string
    Name string
}

type TodoItem struct {
    Id      string
    ListId  string
    Content string
    Done    bool
}

type AppService interface {
    GetUserService(email string, password string) (service UserService, err error)
}

type UserService interface {
    GetTodoLists() (list []*TodoList, err error)
    GetTodoItems(listId string) (list []*TodoItem, err error)
    PutTodoList(name string) (err error)
    CreateTodo(listId string, content string) (err error)
    DoneTodo(todoItemId string) (err error)
    UndoneTodo(todoItemId string) (err error)
}
</code></pre>

<p>Which you can see it's simple Go structs and interfaces. But without logic implementations. Because we want to define our system API interfaces, this file will give the user of the API enough information for what you can do with the API.</p>

<p>Take <code>GetTodoLists</code> for example, client side could use <code>email</code> and <code>password</code> to get a <code>UserService</code>, Which is a way of authentication, that invalid email with password combination can't get <code>UserService</code>, So there is no way to invoke the <code>GetTodoLists</code> api method.</p>

<p>And the <code>GetTodoLists</code> describe clearly that it takes no arguments, But could return a list of <code>TodoList</code>, the <code>TodoList</code> struct includes <code>Name</code> and <code>Id</code> properties.</p>

<p>If I want to invoke the API with JavaScript, I will imagine It would be nice If I can do:</p>

<pre><code>userservice.GetTodoLists(function(list, err){
    for(var i=0; i&lt;list.length; i++){
                console.log(list[i].Name)
            }
});
</code></pre>

<p>Because the <code>GetTodoLists</code> definition have two return values, <code>list</code> and <code>err</code>, So we can see the JavaScript callback that have two arguments. that mapping directly to the Go return values.</p>

<p>The <code>hypermusk</code> command that could generate javascript libraries that can do exactly that.</p>

<pre><code>hypermusk -pkg=github.com/hypermusk/todoapp/todoapi -lang=javascript -outdir=./web
</code></pre>

<p>The <code>-pkg</code> passed in the Go package of the API definition, <code>-lang</code> tells it you want to generate client side library to use to call the API remotely by using JavaScript. and the <code>-outdir</code> will tell it where to generate the file.</p>

<p>So If I ask you how to call the method <code>CreateTodo</code> in JavaScript?</p>

<p>The answer would be:</p>

<pre><code>userservice.CreateTodo("1", "new todo", function(err){
    console.log(err);
})
</code></pre>

<p>And to call the API you defined in Go in another language like Objective C, or Java is as easy as do it in JavaScript. But following the language's idioms.</p>

<h2>The server side implementation</h2>

<p>But If you really call the API with JavaScript, It won't do anything, Because we only defined the interfaces, didn't do any implementation yet.</p>

<p>The implementation of the server side API must be in Go, and it will import the api package to make sure the implementation is following the definition exactly.</p>

<p>First, we will use the <code>hypermusk</code> tool again to generate the glue code to expose those API definition to the outside world through json (at the current stage, we only support expose json through http).</p>

<pre><code>hypermusk -pkg=github.com/hypermusk/todoapp/todoapi -impl=github.com/hypermusk/todoapp/server -lang=server -outdir=./server
</code></pre>

<p>We can see it still uses the <code>todoapi</code> package, because that's the specification of the app. But it adds another argument <code>-impl</code>, Which will hook up the manually implemented package <code>github.com/hypermusk/todoapp/server</code> with the generated glue code. We will write the implementation like this:</p>

<pre><code>type AppServiceImpl struct {
}

type UserServiceImpl struct {
}

func (a *AppServiceImpl) GetUserService(email string, password string) (service todoapi.UserService, err error) {
    if email != "admin@example.com" &amp;&amp; password != "nimda" {
        err = errors.New("wrong credentials")
        return
    }
    service = new(UserServiceImpl)
    return
}

func (u *UserServiceImpl) GetTodoLists() (list []*todoapi.TodoList, err error) {
    return
}

func (u *UserServiceImpl) GetTodoItems(listId string) (list []*todoapi.TodoItem, err error) {
    return
}

func (u *UserServiceImpl) PutTodoList(name string) (err error) {
    return
}

func (u *UserServiceImpl) CreateTodo(listId string, name string) (err error) {
    return
}

func (u *UserServiceImpl) DoneTodo(todoId string) (err error) {
    return
}

func (u *UserServiceImpl) UndoneTodo(todoId string) (err error) {
    return
}

var DefaultAppService = new(AppServiceImpl)
</code></pre>

<p>The last variable <code>DefaultAppService</code> is the secret to hook up the generated code with our API implementation. Since we defined a <code>AppService</code> interface that no other methods returns it. and It has a method called <code>GetUserService</code> that returns the other service, So it's the root.</p>

<p>Notice that we write a dummy implementation of <code>GetUserService</code> to only return the <code>UserService</code> when password is nimda. In there we could validate the user with database and try to get the user's id into <code>UserServiceImpl</code>, So that it can be used to query user's own todo lists. But right now let's say the system only works for the user admin@example.com.</p>

<p>Next we implement the <code>GetTodoLists</code>:</p>

<pre><code>func (u *UserServiceImpl) GetTodoLists() (list []*todoapi.TodoList, err error) {
    withdb(func(db *sql.DB) {
    list = make([]*todoapi.TodoList, 0)
    rows, err := db.Query("SELECT id, name FROM todo_lists ORDER BY id ASC")
    panicIf(err)

    for rows.Next() {
        newL := new(todoapi.TodoList)
        var id int
        err = rows.Scan(&amp;id, &amp;newL.Name)
        panicIf(err)
        newL.Id = fmt.Sprintf("%d", id)
        list = append(list, newL)
    }
    })
    return
}
</code></pre>

<p>It first query from the postgresql table <code>todo_lists</code>, and then populate them into the struct <code>todoapi.TodoList</code>, It's quite straight forward.</p>

<p>Next thing we do is create a http server to serve the API:</p>

<pre><code>package main

import (
    "github.com/hypermusk/todoapp/server/todoapihttpimpl"
    "log"
    "net/http"
)

func main() {

    todoapihttpimpl.AddToMux("/api", http.DefaultServeMux)
    http.DefaultServeMux.Handle("/web/", http.FileServer(http.Dir("../../")))
    err := http.ListenAndServe(":9000", nil)
    if err != nil {
        log.Fatal("ListenAndServe: ", err)
    }
}
</code></pre>

<p>The <code>todoapihttpimpl</code> package is the glue code that <code>hypermusk</code> generated. And it has a <code>AddToMux</code> method that could expose all those APIs through a url like <code>/api/UserService/GetTodoLists.json</code></p>

<p>After this, you start the server with <code>go run main.go</code>, And if there is no compile errors, You should be able to serve the APIs to your javascript, here is the proof.</p>

<p> <img src="/images/todo-lists-app/web_console.png" alt="" /></p>

<p>And how the http round trip is if you want to know the internal of how it works:</p>

<p> <img src="/images/todo-lists-app/tcpspy.png" alt="" /></p>

<p>And the full code of this app is at: <a href="https://github.com/hypermusk/todoapp">https://github.com/hypermusk/todoapp</a></p>

<p>Next: <a href="/2013/09/27/make-an-todo-list-ios-app-with-these-api.html">Make an iOS app with these API</a></p>


<!-- Place this tag after the last +1 button tag. -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>


</div>


  <div class="footer">

    <div class="contact">
      <p>
        <a href="http://github.com/hypermusk/">github.com/hypermusk</a><br />
      </p>
    </div>
  </div>
</div>

  <div class="scripts">
	  <script type="text/javascript">
	  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	  </script>
	  <script type="text/javascript">
	  try {
	  var pageTracker = _gat._getTracker("UA-12459302-2");
	  pageTracker._trackPageview();
	  } catch(err) {}</script>
  </div>
</body>
</html>
